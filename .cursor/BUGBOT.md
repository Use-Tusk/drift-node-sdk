# Tusk Drift Bug Bot

## Checklist for Adding a New Instrumentation

1. **Initialize in `registerDefaultInstrumentations()`**
   - Add to `src/core/TuskDrift.ts` in the `registerDefaultInstrumentations()` method

2. **Add module name to `TuskDriftInstrumentationModuleNames.ts`**
   - Add package name to the array in `src/core/TuskDriftInstrumentationModuleNames.ts`

3. **Add package to `withTuskDrift.ts`**
   - Add to `coreExternals` array in `src/nextjs/withTuskDrift.ts` (inside the `isRecordOrReplay` conditional)

4. **Instrumentation Manifest (auto-generated)**
   - The manifest at `dist/instrumentation-manifest.json` is auto-generated by `scripts/generateManifest.ts` during build
   - Standard instrumentations are detected automatically if they:
     - Have `Instrumentation.ts` in `src/instrumentation/libraries/<name>/`
     - Use `new TdInstrumentationNodeModule({ name: "...", supportedVersions: [...] })`
   - **Manual updates needed for edge cases:**
     - Global patches (no `TdInstrumentationNodeModule`): Add to `GLOBAL_INSTRUMENTATIONS` in the script
     - Internal paths (e.g., `next/dist/...`): Add mapping in `getPublicPackageName()`
   - Keep `name` and `supportedVersions` statically analyzable (no computed expressions)

## Using `matchImportance` for Schema Merges

When setting `matchImportance` on input fields (e.g., to deprioritize certain fields during mock matching), you must add it in **two places**:

1. **During RECORD mode (span creation)**
   - Add `inputSchemaMerges` when calling `SpanUtils.createAndExecuteSpan()`:

   ```typescript
   inputSchemaMerges: {
     fieldName: {
       matchImportance: 0,  // 0 = lowest importance, 1 = highest
     },
   },
   ```

2. **During REPLAY mode (mock fetching)**
   - Add `inputValueSchemaMerges` when calling `findMockResponseAsync()`:

   ```typescript
   inputValueSchemaMerges: {
     fieldName: {
       matchImportance: 0,
     },
   },
   ```

If you only add it in one place, the schema hashes will differ between recording and replay, causing mock matching to fail. See the HTTP instrumentation (`src/instrumentation/libraries/http/mocks/TdMockClientRequest.ts`) for a reference implementation with `headers: { matchImportance: 0 }`.

## Never use `||` for enum or numeric defaults

Use `??` (nullish coalescing) instead of `||` (logical OR) when providing defaults for enums or numeric values. The `||` operator treats `0` as falsy, which silently corrupts valid enum values like `SpanKind.INTERNAL` (0) and `PackageType.UNSPECIFIED` (0).

```typescript
// BAD: 0 is falsy, so INTERNAL becomes CLIENT
kind: options.kind || SpanKind.CLIENT

// GOOD: ?? only falls back on null/undefined
kind: options.kind ?? SpanKind.CLIENT
```

## Instrumentation Self-Reference (POTENTIAL BUG)

**Problem**: Using instrumented global functions within the SDK's own instrumentation code can cause:

- Circular dependencies between instrumentation and utility modules
- Infinite recursion when instrumented code calls itself
- Incorrect behavior where SDK internals use mocked/replayed data instead of real data

**Examples of problematic code**:

```typescript
// BAD: Using potentially instrumented Date in logger
private formatMessage(message: string): string {
  const timestamp = new Date().toISOString(); // This Date might be instrumented!
  return `${timestamp} ${message}`;
}

// BAD: Using potentially instrumented env vars in SDK code
const config = process.env.API_KEY; // This might be mocked in replay mode!
```

**Solution**: Use `OriginalGlobalUtils` or create new original utilities to access uninstrumented versions:

```typescript
// GOOD: Using original Date for SDK internal logging
import { OriginalGlobalUtils } from '../utils/originalGlobalUtils';

private formatMessage(message: string): string {
  const timestamp = OriginalGlobalUtils.getOriginalDate().toISOString();
  return `${timestamp} ${message}`;
}

// GOOD: Using original process.env for SDK internal config
const config = OriginalGlobalUtils.getOriginalProcessEnvVar("API_KEY");
```
